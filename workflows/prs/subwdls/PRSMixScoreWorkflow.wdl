version 1.0

workflow PRSMixScoreWorkflow {
    input {
        Array[File] raw_scores
        File score_weights
        String output_basename
        # Docker images
        String docker_image = "python:3.11"
    }

    # Calculate raw PRS mix score
    call CalculateMixScore {
        input:
            raw_scores = raw_scores,
            score_weights = score_weights,
            output_basename = output_basename,
            docker_image = docker_image
    }

    output {
        File prs_mix_raw_score = CalculateMixScore.prs_mix_raw_score
    }
}

task CalculateMixScore {
    input {
        Array[File] raw_scores
        File score_weights
        String output_basename
        String docker_image
        Int disk_size = ceil(size(raw_scores, "GB") + size(score_weights, "GB")) + 10
        Int mem_size = 2
        Int preemptible = 1
    }

    String OUTPUT = "~{output_basename}.mix.sscore"

    command <<<
    python3 <<EOF > '~{OUTPUT}'
    import sys
    import os
    import operator
    import re

    # -----------------------------------------------------------------------------

    def parse_variant_weights_id(rawscores_file,
                                 _pgsid_re=re.compile(r'(PGS\d{1,6})(?!\d)')):
        '''Extract the variant weight id from basename of RAWSCORES_FILE.'''

        match = _pgsid_re.search(rawscores_file)
        if not match:
            raise ValueError(f'cannot parse pgsid from {rawscores_file!r}')
        return match.group(0)


    def read_scores(scoresfiles, scorecolumn):
        '''Return data given in files listed in SCORESFILES.

        Inputs:
        scoresfile:   file containing the paths to raw scores files, as
                      those generated by a PLINK2 --SCORE command;
        scorecolumn:  name of the column of the files mentioned in scoresfiles
                      whose values will be extracted by the function.

        Outputs:
        collect:      a two-dimensional dictionary of floating point numbers.
                      The first level of keys in this dictionary are the sample
                      ids given in the first column of the files listed in
                      SCORESFILES; the second level of keys are the variant
                      weights ids encoded in the basenames of the files listed
                      in SCORESFILES; the combination of sample id and variant
                      weights id uniquely determine a floating number, and this
                      is the value assigned to that combination of keys;
        columnlabels: a list of the variant weights ids encoded in the
                      basenames of the files listed in SCORESFILES;
        rowlabels:    a list of the sample ids found in the first column of the
                      files listed in SCORESFILES; (the first columns of all
                      these files must contain the same sample ids, up to
                      reordering).
        '''

        def read_scoresfiles():
            filepaths = []
            with open(scoresfiles) as reader:
                for rawline in reader:
                    filepaths.append(rawline.rstrip('\r\n'))
            return filepaths

        def get_getter(firstline):
            labels = firstline.strip('\r\n').split('\t')
            return operator.itemgetter(0, labels.index(scorecolumn))

        filepaths = read_scoresfiles()

        columnlabels = list(map(parse_variant_weights_id, filepaths))

        collect = dict()
        rowlabels = []
        for variant_weights_id, filepath in zip(columnlabels, filepaths):
            keep_rowlabels = not rowlabels
            with open(filepath) as reader:
                getter = get_getter(next(reader))
                for rawline in reader:
                    row = getter(rawline.rstrip('\r\n').split('\t'))
                    sampleid = row[0]
                    if keep_rowlabels:
                        rowlabels.append(sampleid)
                    record = collect.setdefault(sampleid, dict())
                    record[variant_weights_id] = float(row[1])

        return collect, columnlabels, rowlabels


    def read_scoreweights(scoreweights, labels):
        '''Return dictionary of the values in SCOREWEIGHTS's second column.

        The first row of SCOREWEIGHTS will be treated as headers, and skipped.

        In the remaining rows, the first column must consist of the same
        strings as those in LABELS, up to reordering.  These strings will be
        the keys for the returned dictionary.  The second column must contain
        floating point numbers.
        '''

        seen = set()
        collect = dict()
        # weights_sum = 0

        with open(scoreweights) as reader:

            next(reader)  # header row discarded

            for rawline in reader:
                row = rawline.rstrip('\n').split('\t')
                assert len(row) == 2

                variant_weights_id = row[0]
                assert variant_weights_id not in seen, \
                    f'scores weights file contains repeated ids'
                seen.add(variant_weights_id)

                weight = float(row[1])
                collect[variant_weights_id] = weight

                # weights_sum += weight

        assert sorted(labels) == sorted(collect.keys()), \
            ('variant weights ids in score weights file are not consistent '
             'with basenames of scores files')

        # return {variant_weights_id: collect[variant_weights_id]/weights_sum
        #         for variant_weights_id in labels}

        return collect


    def main():

        scoresfiles  = '~{write_lines(raw_scores)}'
        scoreweights = '~{score_weights}'

        outputheader = '#IID\tNAMED_ALLELE_DOSAGE_SUM\tSCORE1_AVG\tSCORE1_SUM'
        outputlabels = outputheader.split('\t')
        scorelabel = outputlabels[3]
        outputtemplate = '{}\tNA\tNA\t{}'

        scores, columnlabels, rowlabels = read_scores(scoresfiles, scorelabel)

        scoreweights = read_scoreweights(scoreweights, columnlabels)

        print(outputheader)
        for sampleid in rowlabels:
            row = scores[sampleid]
            # the for-loop below computes the inner product of a table row with
            # score weights vector
            weighted_sum = 0
            for variant_weights_id in columnlabels:
                weighted_sum += (row[variant_weights_id] *
                                 scoreweights[variant_weights_id])

            print(outputtemplate.format(sampleid, f'{weighted_sum:.4g}'))

    # -----------------------------------------------------------------------------

    main()
    EOF
    >>>

    runtime {
        docker: "~{docker_image}"
        disks: "local-disk " + disk_size + " SSD"
        memory: mem_size + "GB"
        preemptible: preemptible
    }

    output {
        File prs_mix_raw_score = OUTPUT
    }
}
